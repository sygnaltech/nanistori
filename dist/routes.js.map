{
  "version": 3,
  "sources": ["../src/page/home.ts", "../src/engine/core.ts", "../src/site.ts", "../src/engine/routeDispatcher.ts", "../src/page/redir.ts", "../src/routes.ts"],
  "sourcesContent": ["\n/*\n * Page | Home\n */\n\nimport { IRouteHandler } from \"../engine/routeDispatcher\";\n \n\nexport class HomePage implements IRouteHandler {\n\n  constructor() {\n  }\n\n  setup() {\n        \n  }\n\n  exec() {\n\n  }\n\n}\n", "\n\n// Determine Webflow breakpoint?\n\n\n// Utility function to get a query parameter value by name\nexport function getQueryParam(name: string): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get(name);\n}\n\n\n// Add a new async script to the page\n// at the end of the body\nexport function loadScriptHead(url: string, async: boolean = false): void {\n    const script = document.createElement('script');\n    script.src = url;\n    script.async = async;\n    document.head.appendChild(script);\n}\n\nexport function loadScriptBody(url: string): void {\n    const script = document.createElement('script');\n    script.src = url;\n//    script.async = true;\n    document.body.appendChild(script);\n}\n\nexport function loadScriptBlockHead(script: string): void {\n    const scriptElem = document.createElement('script');\n//    scriptElem.type = 'text/javascript';\n    scriptElem.textContent = script;\n    document.head.appendChild(scriptElem);\n}\n\n// Add a new CSS file to the page\nexport function loadCSS(url: string): void {\n    const link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = url;\n    document.head.appendChild(link);\n}\n\n// Add a new Engine CSS file to the page\n// Expected to be in the /dist/css/ dir \nexport function loadEngineCSS(cssFileName: string): void {\n    // Get the URL of the currently executing script\n    const currentScript = document.currentScript as HTMLScriptElement;\n    if (currentScript) {\n        const scriptURL = new URL(currentScript.src);\n        const origin = scriptURL.origin;\n        const path = scriptURL.pathname.substring(0, scriptURL.pathname.lastIndexOf('/'));\n\n        const cssURL = `${origin}${path}/css/${cssFileName}`;\n        loadCSS(cssURL);\n    } else {\n        console.error('Unable to determine the currently executing script.');\n    }\n}\n\n// Add a new Style element to the page\nexport function loadStyle(css: string): void {\n    const style = document.createElement('style');\n//    link.rel = 'stylesheet';\n//    link.href = url;\n    style.innerText = css;\n    document.head.appendChild(style);\n}\n\n// Replace an existing script source\nexport function replaceScriptSource(element: HTMLScriptElement, newSrc: string): void {\n    element.src = newSrc;\n}\n\n// Replace an existing CSS source\nexport function replaceCSSLink(element: HTMLLinkElement, newHref: string): void {\n    element.href = newHref;\n}\n\n// Function to prepend text to the document title in development mode\nexport function prependToTitle(text: string): void {\n    document.title = `${text}${document.title}`;\n}\n\n// Function to get the current script URL\nexport function getCurrentScriptUrl(): string | null {\n    // Check if document.currentScript is supported\n    if (document.currentScript) {\n        // Cast to HTMLScriptElement and get the src attribute\n        const currentScript = document.currentScript as HTMLScriptElement;\n        return currentScript.src;\n    }\n    // For browsers that do not support document.currentScript\n    console.error(\"document.currentScript is not supported in this browser.\");\n    return null;\n}\n\n\nexport function findAncestorWithAttribute(element: HTMLElement, attributeName: string): HTMLElement | null {\n    let currentElement: HTMLElement | null = element;\n\n    while (currentElement) {\n        if (currentElement.hasAttribute(attributeName)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n\n    return null;\n}\n\nexport function getAncestorAttributeValue(element: HTMLElement, attributeName: string): string | null {\n    let currentElement: HTMLElement | null = element;\n\n    while (currentElement) {\n        if (currentElement.hasAttribute(attributeName)) {\n            return currentElement.getAttribute(attributeName);\n        }\n        currentElement = currentElement.parentElement;\n    }\n\n    return null;\n}\n\nexport function hasAncestorWithAttribute(element: HTMLElement, attributeName: string): boolean {\n    return findAncestorWithAttribute(element, attributeName) !== null;\n}\n\nexport function convertToPixels(value: string, contextElement: HTMLElement = document.documentElement): number {\n    // Parse the numeric value and unit, including negative values\n    const match = value.match(/^(-?\\d+\\.?\\d*)(rem|em|px|vh|vw|%)$/);\n    if (!match) throw new Error('Invalid value format');\n\n    const [, amountStr, unit] = match;\n    const amount = parseFloat(amountStr);\n\n    // Convert based on the unit\n    switch (unit) {\n        case 'px':\n            return amount;\n        case 'rem':\n            return amount * parseFloat(getComputedStyle(document.documentElement).fontSize);\n        case 'em':\n            // For 'em', it's relative to the font-size of the context element.\n            return amount * parseFloat(getComputedStyle(contextElement).fontSize);\n        case 'vh':\n            return amount * window.innerHeight / 100;\n        case 'vw':\n            return amount * window.innerWidth / 100;\n        case '%':\n            // For %, it's relative to the parent element's size. This can be tricky as it depends on the property (width, height, font-size, etc.).\n            // In this example, we'll use it relative to the width of the context element, but you might need to adjust based on your specific use case.\n            return amount * contextElement.clientWidth / 100;\n        default:\n            throw new Error('Unsupported unit');\n    }\n}\n\n\n/*\n// Example usage:\nconst pixelValue = convertToPixels(\"10vh\");\nconsole.log(pixelValue);\n*/\n\nasync function getResponseHeader(headerName: string, url: string | undefined = undefined): Promise<string | undefined> {\n\n    const headers: Headers | undefined = await getResponseHeaders(url);\n\n    if(!headers)\n        return undefined;\n\n    if(!headers.has(headerName)) \n        return undefined;\n\n    return headers.get(headerName) || undefined;\n\n}\n\n// Function to check if the reverse proxy header is present\nasync function getResponseHeaders(url: string | undefined = undefined): Promise<Headers | undefined> {\n    try {\n\n        if(!url) {\n            url = window.location.href\n        }\n\n        const response = await fetch(url, {\n            method: 'HEAD', // Only fetch headers\n        });\n\n        return response.headers;\n\n    } catch (error) {\n        console.error('Error checking reverse proxy header:', error);\n    }\n\n    return undefined;\n}\n\n", "\n/*\n * Site\n */\n\nimport { IRouteHandler } from \"./engine/routeDispatcher\";\nimport { loadCSS, loadEngineCSS, loadScriptBlockHead, loadScriptHead } from \"./engine/core\";\n\n// import gsap from 'gsap'; \n \n// Define the type for the config object\ninterface MembershipRoutingConfig {\n  routeAfterFirstLogin: string;\n  routeAfterLogin: string;\n}\n\n// // Ensure the window.sa5 array exists and has the correct type\n// declare global {\n//   interface Window {\n//     sa5: Array<[string, (config: MembershipRoutingConfig) => MembershipRoutingConfig]>;\n//   }\n// }\n// // Initialize window.sa5 if it doesn't exist\n// window.sa5 = window.sa5 || [];\n\nexport class Site implements IRouteHandler {\n\n  constructor() {\n  }\n\n  setup() {\n\n    console.log(\"site setup\"); \n\n    // Site-wide CSS\n    loadEngineCSS(\"site.css\"); \n\n    /**\n     * SA5 User Accounts\n     */\n\n    loadCSS(\"https://cdn.jsdelivr.net/gh/sygnaltech/webflow-util@5.3.4/dist/css/webflow-membership.css\")\n    loadScriptHead(\n      \"https://cdn.jsdelivr.net/gh/sygnaltech/webflow-util@5.4.0/dist/nocode/webflow-membership.js\", \n      true\n    ); \n\n    // Memberships Config \n    window.sa5 = window.sa5 || [];\n    window.sa5.push(['getMembershipConfig', \n      (config) => {\n\n        // Apply any configuration settings here\n        // such as access groups \n        return config;\n      }]);\n\n    // Routing Config\n    window.sa5 = window.sa5 || [];\n    window.sa5.push(['getMembershipRoutingConfig', \n      (config) => {\n\n//        config.routeAfterFirstLogin = '/u/new';\n        config.routeAfterLogin = '/redir';\n        return config;\n      }]); \n\n  }\n\n  exec() {\n\n  }\n\n}\n", "/*\n * Sygnal\n * Route Dispatcher\n * \n */\n\nimport { Site } from \"../site\";\n\n\n \n\nexport interface IRouteHandler {\n\n    setup(): void;\n    \n    exec(): void; \n  \n}\n\n  \ntype RouteHandler = () => void;\ntype RouteHandlerClass = { new (): IRouteHandler };\n\nexport interface Routes {\n    [path: string]: RouteHandlerClass;\n}\n\nexport class RouteDispatcher {\n\n    routes!: Routes;\n\n    constructor() {\n    }\n\n    matchRoute(path: string): RouteHandlerClass | null {\n        for (const route in this.routes) {\n            if (route.endsWith('*')) {\n                // If the route ends with *, treat it as a wildcard\n                const baseRoute = route.slice(0, -1); // Remove the * from the end\n                if (path.startsWith(baseRoute)) {\n                    return this.routes[route];\n                }\n            } else if (route === path) {\n                // Exact match\n                return this.routes[route];\n            }\n        }\n        return null; // No matching route found\n    }\n    \n    setupRoute() {\n\n        // Pre-init site-level\n        (new Site().setup());\n\n        // Pre-init route-level\n        const path = window.location.pathname;\n        const HandlerClass = this.matchRoute(path);\n        if (HandlerClass) {\n            const handlerInstance = new HandlerClass();\n            handlerInstance.setup(); \n        } else {\n//            console.log('No specific function for this path.');\n        }\n    }\n\n    execRoute() {\n\n        // Init site-level\n        (new Site().exec());\n\n        // Init route-level\n        const path = window.location.pathname;\n        const HandlerClass = this.matchRoute(path);\n        if (HandlerClass) {\n            const handlerInstance = new HandlerClass();\n            handlerInstance.exec(); \n        } else {\n//            console.log('No specific function for this path.');\n        }\n    }\n    \n}", "\n/*\n * Page | Redir\n */\n\nimport { IRouteHandler } from \"../engine/routeDispatcher\";\n \n\nexport class RedirPage implements IRouteHandler {\n\n  constructor() {\n  }\n\n  setup() {\n       \n        // Routing Config\n        window.sa5 = window.sa5 || [];\n        window.sa5.push(['userInfoChanged', \n          (user) => {\n            if(user.user_data_loaded.custom_fields) {\n//console.log(user); \n  //            console.log(user.data[\"userid\"]); \n              location.href= `/account/${user.data[\"userid\"]}`; \n\n              return;\n            }\n          }]); \n\n  }\n\n  exec() {\n\n\n    \n  }\n\n}\n", "/*\n * SITE\n * Main entry point\n * \n * https://engine.sygnal.com/\n * \n * ENGINE MODE\n * ?engine.mode=dev\n * ?engine.mode=prod\n * \n */\n\nimport { HomePage } from \"./page/home\";\nimport { RouteDispatcher } from \"./engine/routeDispatcher\";\nimport { RedirPage } from \"./page/redir\";\n\nexport const routeDispatcher = (): RouteDispatcher => {\n    \n    var routeDispatcher = new RouteDispatcher();\n    routeDispatcher.routes = {\n\n        // Site paes\n        '/': HomePage,\n        \n        '/redir': RedirPage, \n        // TEST Pages\n\n    };\n\n    return routeDispatcher;\n}\n\n"],
  "mappings": "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",
  "names": ["routeDispatcher"]
}
